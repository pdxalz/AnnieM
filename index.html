<!DOCTYPE html>
<html lang="en">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<head>
    <title>Sauvie Wind Data</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.js" type="text/javascript">
    </script>
    <link rel="stylesheet" href="style.css">
    <script type="text/javascript" language="javascript">
        var mqtt;
        var reconnectTimeout = 10000;
        var host = "test.mosquitto.org"; //MQTT Server, 
        var port = 8081;
        var chart;
        var windData = [];               // Array of wind reports, index is hour
        var latestTime = new Date(0);    // Time of most recent report

        function onFailure(message) {
            console.log("Connection Attempt to Host " + host + "Failed");
            setTimeout(MQTTconnect, reconnectTimeout);
        }

        // Handle subscribed MQTT Message
        function onMessageArrived(msg) {
            var wind_data = msg.payloadString;
            // console.log("dest: :" + msg.destinationName);

            if (msg.destinationName.search("recent") >= 0) {
                addDataToRecent(wind_data);
            } else {
                plotWindData(wind_data);
            }
        }

        // Convert a 0-360 degree direction to a compass point and degrees from it
        function directionString(direction) {
            const dir_dict = {
                0: "N",
                1: "NE",
                2: "E",
                3: "SE",
                4: "S",
                5: "SW",
                6: "W",
                7: "NW"
            }
            var dir_num = Number(direction);
            var dir_index = Math.floor(((dir_num + 22) % 360) / 45);
            var dir_remainder = (dir_num - dir_index * 45);
            dir_remainder = (dir_remainder > 23) ? dir_remainder - 360 : dir_remainder;
            return dir_dict[dir_index] + " " + "<small>" + dir_remainder + "&#176</small>";
        }

        // Update the HTML reporting the most recent data
        function addDataToRecent(recent_data) {
            try {
                recent_json = JSON.parse(recent_data);
            }
            catch (err) {
                console.log(err.message);
            }
            var recentWind = document.getElementById("recent-wind");
            var devInfo = document.getElementById("devInfo");
         
            recentWind.innerHTML =
                "<h2><small>"  + recent_json.time + "</small><br>" +  recent_json.sp + "<small>mph</small>  " +directionString(recent_json.dir) + "<small>(" + recent_json.dir + "&#176)</small>"
                " Direction: " + directionString(recent_json.dir) + "(" + recent_json.dir + ")" + recent_json.time + "</h2>";
           
            devInfo.innerHTML = "<p> battery: " + recent_json.mv +"</p>";
        }

        // Hack to make degree data fit into windspeed data, North is center of chart
        function northCenter(degrees) {
            return ((degrees + 180) % 360) / 9;
        }

        function timeString(time24) {
            if (time24 == 0)
                return "12am";
            else if (time24 == 12)
                return "12pm";
            else if (time24 < 12)
                return time24.toString() + "am";
            else
                return (time24 - 12).toString() + "pm"
        }

        // Adds a wind speed message to the windData array then redraw the chart of all data
        function plotWindData(wind_data) {
            try {
                wind_json = JSON.parse(wind_data);
            }
            catch (err) {
                console.log(err.message);
            }
            // get the time of the wind sample
            var time = new Date(wind_json.time);
            time.setTime(time.getTime() + (7 * 60 * 60 * 1000) + (30 * 24 * 60 * 60 * 1000));  // Need to remove UTC offset in Annie code
            //           console.log("timestamp: " + wind_json.time + "   latest: ", latestTime);

            // the sample hour is the index to the windData array
            var hour = time.getHours();
            windData[hour] = wind_json.wind;

            // keep track of the most recent time read
            if (time > latestTime) {
                latestTime = time;
            }

            if (time.getTime() < (Date.now() - (2 * 24 * 60 * 60 * 1000))) {
                for (var i = windData[hour].length - 1; i >= 0; --i) {
                    windData[hour][i][1] = 177;
                }
            }
            // strip off the 0,0 "no data" values off the end.
            for (var i = windData[hour].length - 1; i >= 0; --i) {
                if (windData[hour][i][0] == 0 && windData[hour][i][1] == 0) {
                    windData[hour].pop();
                }
                else {
                    break;
                }
            }

            var sampleTimes = [];
            var speedData = [];
            var dirData = [];
            var hour = latestTime.getHours();

            // Scan through the windData in order by time and
            // create the arrays for the chart.
            for (var i = 0; i < windData.length; ++i) {
                var index = (hour + i + 1) % windData.length;
                for (var j = 0; j < windData[index].length; ++j) {
                    sampleTimes.push(j == 0 ? timeString(index) : "");
                    speedData.push(windData[index][j][0]);
                    dirData.push(northCenter(windData[index][j][1]));
                }
            }

            chart.data.datasets[0].data = speedData;
            chart.data.datasets[1].data = dirData;
            chart.data.labels = sampleTimes;
            chart.update();
        }

        // MQTT connection
        function onConnect() {
            // Once a connection has been made, make a subscription and send a message.

            console.log("Connected ");
            mqtt.subscribe("zimbuktu/wind/#");
            mqtt.subscribe("zimbuktu/recent/#");
        }

        function MQTTconnect() {
            console.log("connecting to " + host + " " + port);
            var x = Math.floor(Math.random() * 10000);
            var cname = "orderform-" + x;
            mqtt = new Paho.MQTT.Client(host, port, cname);
            //document.write("connecting to "+ host);
            var options = {
                timeout: 3,
                onSuccess: onConnect,
                onFailure: onFailure,
                useSSL: true
            };
            mqtt.onMessageArrived = onMessageArrived

            mqtt.connect(options); //connect
        }

    </script>
</head>

<body>
    <div class="w3-container w3-indigo">
        <h1>SAUVIE ISLAND WIND</h1>
    </div>
    <div class="w3-panel w3-pale-blue">
        <div id="recent-wind"></div>
    </div>
    <div class="w3-panel w3-pale-blue">
        <p style="color:red;"> There are data corruption issues with the wind chart.  Please ignore any data if the direction is at the top of the chart.</p>
        <p> The blue line is the direction. North is at the center of the chart. </p>
        <p> Updates occur every 5 minutes from 10AM to 9PM if it is windy. Otherwise it is only updated on the hour.</p>
    </div>
   

    <div class="w3-panel w3-pale-blue" style="direction: rtl; overflow-x: auto; overflow-y: hidden;" >
        <div style="width:3000px; height: 500px">
            <canvas id="myChart" height="500" width="0"></canvas>
        </div>
    </div>

    <div class="w3-panel w3-pale-blue">
        <div id="devInfo"></div>
    </div>

    <script>
        MQTTconnect();

        chart = new Chart("myChart", {
            type: "line",
            data: {
                datasets: [{
                    label: "Wind Speed",
                    pointRadius: 1,
                    pointBackgroundColor: "rgb(0,0,255)",
                    borderColor: "green"
                }, {
                    label: "Direction (North at middle)",
                    pointRadius: 1,
                    pointBackgroundColor: "rgb(0,0,255)",
                    borderColor: "blue",
                    fill: false,
                    borderWidth: -1
                },
                ]
            },
            options: {
                legend: { display: true, 
                          defaultFontSize: 24,
                          fontColor: 'red',},

                scales: {
                    xAxes: [{ ticks: { min: 40, max: 290 } }],
                    yAxes: [{
                        position: 'right',
                        ticks: {
                            min: 0,
                            max: 40,
                        }
                    },
                    {
                        position: 'right',

                        ticks: {
                            fontColor: 'blue',
                            min: 0, max: 8, callback: function (value) {
                                var x = ["S", "SW", "W", "NW", "N", "NE", "E", "SE", "S"];
                                return x[value % x.length];

                            }
                        }
                    }],
                }
            }
        });
    </script>
</body>

</html>